var parse = function (quasis, expressions) {
  var quasiIndex = 0;
  var stackIndex = 0;
  var sequenceStack = [];
  var rootSequence = {
    type: 'sequence',
    sequence: [],
    alternation: null
  };
  var currentGroup = null;
  var lastMatch;
  var currentSequence = rootSequence;

  while (stackIndex < quasis.length + expressions.length) {
    if (stackIndex % 2 !== 0) {
      var expression = expressions[stackIndex++ >> 1];
      currentSequence.sequence.push({
        type: 'expression',
        expression: expression,
        quantifier: null
      });
    }

    var quasi = quasis[stackIndex >> 1];

    while (quasiIndex < quasi.length) {
      var char = quasi[quasiIndex++];

      if (char === ' ' || char === '\t' || char === '\r' || char === '\n') {
        continue;
      } else if (char === '|' && currentSequence.sequence.length > 0) {
        currentSequence = currentSequence.alternation = {
          type: 'sequence',
          sequence: [],
          alternation: null
        };
        continue;
      } else if (char === ')' && currentSequence.sequence.length > 0) {
        currentGroup = null;
        currentSequence = sequenceStack.pop();

        if (currentSequence) {
          continue;
        }
      } else if (char === '(') {
        currentGroup = {
          type: 'group',
          sequence: {
            type: 'sequence',
            sequence: [],
            alternation: null
          },
          capturing: true,
          lookahead: null,
          quantifier: null
        };
        sequenceStack.push(currentSequence);
        currentSequence.sequence.push(currentGroup);
        currentSequence = currentGroup.sequence;
        continue;
      } else if (char === '?' && currentSequence.sequence.length === 0 && currentGroup) {
        var nextChar = quasi[quasiIndex++];

        if (!nextChar) {
          throw new SyntaxError('Unexpected end of input after ' + char);
        }

        if (nextChar === ':') {
          currentGroup.capturing = false;
          continue;
        } else if (nextChar === '=') {
          currentGroup.capturing = false;
          currentGroup.lookahead = 'positive';
          continue;
        } else if (nextChar === '!') {
          currentGroup.capturing = false;
          currentGroup.lookahead = 'negative';
          continue;
        }
      } else if ((char === '?' || char === '+' || char === '*') && (lastMatch = currentSequence.sequence[currentSequence.sequence.length - 1])) {
        if (lastMatch.type === 'group' && lastMatch.lookahead) {
          throw new SyntaxError('Unexpected quantifier on lookahead group');
        }

        lastMatch.quantifier = {
          type: 'quantifier',
          required: char === '+',
          singular: char === '?'
        };
        continue;
      }

      throw new SyntaxError('Unexpected token ' + char);
    }

    stackIndex++;
    quasiIndex = 0;
  }

  return rootSequence;
};

var SharedIds = function SharedIds(t) {
  this.t = t;
  this.execId = t.identifier('_exec');
  this.substrId = t.identifier('_substr');
  this.patternId = t.identifier('_pattern');
  this.tagId = t.identifier('tag');
};
var prototypeAccessors = {
  node: {
    configurable: true
  },
  match: {
    configurable: true
  },
  state: {
    configurable: true
  },
  exec: {
    configurable: true
  },
  substr: {
    configurable: true
  },
  pattern: {
    configurable: true
  },
  tag: {
    configurable: true
  }
};

prototypeAccessors.node.get = function () {
  return this.t.identifier('node');
};

prototypeAccessors.match.get = function () {
  return this.t.identifier('match');
};

prototypeAccessors.state.get = function () {
  return this.t.identifier('state');
};

prototypeAccessors.exec.get = function () {
  return this.t.identifier(this.execId.name);
};

prototypeAccessors.substr.get = function () {
  return this.t.identifier(this.substrId.name);
};

prototypeAccessors.pattern.get = function () {
  return this.t.identifier(this.patternId.name);
};

prototypeAccessors.tag.get = function () {
  return this.t.identifier(this.tagId.name);
};

Object.defineProperties(SharedIds.prototype, prototypeAccessors);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var t;
var ids = {};
function initGenerator(_ids, _t) {
  ids = _ids;
  t = _t;
}
/** var id = state.index; */

var AssignIndexNode = function AssignIndexNode(id) {
  this.id = id;
};

AssignIndexNode.prototype.statement = function statement() {
  var member = t.memberExpression(ids.state, t.identifier('index'));
  return t.variableDeclaration('var', [t.variableDeclarator(this.id, member)]);
};
/** state.index = id; */


var RestoreIndexNode = function RestoreIndexNode(id) {
  this.id = id;
};

RestoreIndexNode.prototype.statement = function statement() {
  var expression = t.assignmentExpression('=', t.memberExpression(ids.state, t.identifier('index')), this.id);
  return t.expressionStatement(expression);
};
/** var id = node.length; */


var AssignLengthNode = function AssignLengthNode(id) {
  this.id = id;
};

AssignLengthNode.prototype.statement = function statement() {
  return t.variableDeclaration('var', [t.variableDeclarator(this.id, t.memberExpression(ids.node, t.identifier('length')))]);
};
/** node.length = id; */


var RestoreLengthNode = function RestoreLengthNode(id) {
  this.id = id;
};

RestoreLengthNode.prototype.statement = function statement() {
  var expression = t.assignmentExpression('=', t.memberExpression(ids.node, t.identifier('length')), this.id);
  return t.expressionStatement(expression);
};
/** return; break id; */


var AbortNode = function AbortNode(id) {
  this.id = id || null;
};

AbortNode.prototype.statement = function statement() {
  var statement = this.id ? t.breakStatement(this.id) : t.returnStatement();
  return statement;
};
/** if (condition) { return; break id; } */


var AbortConditionNode = function AbortConditionNode(condition, opts) {
  this.condition = condition || null;
  this.abort = opts.abort;
  this.abortCondition = opts.abortCondition || null;
  this.restoreIndex = opts.restoreIndex;
};

AbortConditionNode.prototype.statement = function statement() {
  return t.ifStatement(this.condition, t.blockStatement([this.restoreIndex.statement(), this.abort.statement()].filter(Boolean)), this.abortCondition ? this.abortCondition.statement() : null);
};
/** Generates a full matcher for an expression */


var ExpressionNode = function ExpressionNode(ast, depth, opts) {
  this.ast = ast;
  this.depth = depth || 0;
  this.capturing = !!opts.capturing;
  this.restoreIndex = opts.restoreIndex;
  this.restoreLength = opts.restoreLength || null;
  this.abortCondition = opts.abortCondition || null;
  this.abort = opts.abort || null;
};

ExpressionNode.prototype.statements = function statements() {
  var execMatch = this.ast.expression;
  var assignMatch = t.assignmentExpression('=', ids.match, execMatch);
  var successNodes = t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(ids.node, t.identifier('push')), [ids.match]))]);
  var abortNodes = t.blockStatement([this.abortCondition && this.abortCondition.statement(), this.abort && this.restoreLength && this.restoreLength.statement(), this.restoreIndex && this.restoreIndex.statement(), this.abort && this.abort.statement()].filter(Boolean));
  return [!this.capturing ? t.ifStatement(t.unaryExpression('!', execMatch), abortNodes) : t.ifStatement(assignMatch, successNodes, abortNodes)];
};
/** Generates a full matcher for a group */


var GroupNode = function GroupNode(ast, depth, opts) {
  this.ast = ast;
  this.depth = depth || 0;

  if (ast.sequence.length === 1) {
    return new ExpressionNode(ast.sequence[0], depth, opts);
  }

  var lengthId = t.identifier("length_" + depth);

  var childOpts = _extends({}, opts, {
    capturing: !!opts.capturing && !!ast.capturing
  });

  this.assignLength = null;

  if (!childOpts.restoreLength && childOpts.capturing) {
    this.assignLength = new AssignLengthNode(lengthId);
    childOpts.restoreLength = new RestoreLengthNode(lengthId);
  }

  this.alternation = new AlternationNode(ast.sequence, depth + 1, childOpts);
};

GroupNode.prototype.statements = function statements() {
  return [this.assignLength && this.assignLength.statement()].concat(this.alternation.statements()).filter(Boolean);
};
/** Generates looping logic around another group or expression matcher */


var QuantifierNode = function QuantifierNode(ast, depth, opts) {
  var quantifier = ast.quantifier;
  this.ast = ast;
  this.depth = depth || 0;
  var invertId = t.identifier("invert_" + this.depth);
  var loopId = t.identifier("loop_" + this.depth);
  var iterId = t.identifier("iter_" + this.depth);
  var indexId = t.identifier("index_" + this.depth);
  var ChildNode = ast.type === 'group' ? GroupNode : ExpressionNode;

  var childOpts = _extends({}, opts);

  this.assignIndex = null;
  this.restoreIndex = null;
  this.blockId = null;
  this.abort = null;

  if (ast.type === 'group' && !!ast.lookahead) {
    this.restoreIndex = new RestoreIndexNode(indexId);
    this.assignIndex = new AssignIndexNode(indexId);
  }

  if (ast.type === 'group' && ast.lookahead === 'negative') {
    childOpts.abort = new AbortNode(invertId);
    childOpts.restoreIndex = this.restoreIndex;
    this.restoreIndex = opts.restoreIndex;
    this.blockId = invertId;
    this.abort = opts.abort;
  }

  if (quantifier && !quantifier.singular && quantifier.required) {
    childOpts.abortCondition = new AbortConditionNode(iterId, _extends({}, opts, {
      restoreIndex: new RestoreIndexNode(indexId),
      abort: new AbortNode(loopId)
    }));
  } else if (quantifier && !quantifier.singular) {
    childOpts.restoreLength = null;
    childOpts.restoreIndex = new RestoreIndexNode(indexId);
    childOpts.abort = new AbortNode(loopId);
    childOpts.abortCondition = null;
  } else if (quantifier && !quantifier.required) {
    childOpts.restoreIndex = new RestoreIndexNode(indexId);
    childOpts.abortCondition = null;
    childOpts.abort = null;
  }

  this.childNode = new ChildNode(ast, depth, childOpts);
};

QuantifierNode.prototype.statements = function statements() {
  var ref = this.ast;
  var quantifier = ref.quantifier;
  var loopId = t.identifier("loop_" + this.depth);
  var iterId = t.identifier("iter_" + this.depth);
  var indexId = t.identifier("index_" + this.depth);
  var assignIndex = new AssignIndexNode(indexId);
  var statements;

  if (quantifier && !quantifier.singular && quantifier.required) {
    statements = [t.labeledStatement(loopId, t.forStatement(t.variableDeclaration('var', [t.variableDeclarator(iterId, t.numericLiteral(0))]), t.booleanLiteral(true), t.updateExpression('++', iterId), t.blockStatement([assignIndex.statement()].concat(this.childNode.statements()))))];
  } else if (quantifier && !quantifier.singular) {
    statements = [t.labeledStatement(loopId, t.whileStatement(t.booleanLiteral(true), t.blockStatement([assignIndex.statement()].concat(this.childNode.statements()))))];
  } else if (quantifier && !quantifier.required) {
    statements = [assignIndex.statement()].concat(this.childNode.statements());
  } else {
    statements = this.childNode.statements();
  }

  if (this.blockId && this.assignIndex && this.restoreIndex) {
    statements = [t.labeledStatement(this.blockId, t.blockStatement([this.assignIndex.statement()].concat(statements, [this.restoreIndex.statement()], [this.abort.statement()]).filter(Boolean)))].filter(Boolean);
  } else if (this.assignIndex && this.restoreIndex) {
    statements.unshift(this.assignIndex.statement());
    statements.push(this.restoreIndex.statement());
  }

  return statements;
};
/** Generates a matcher of a sequence of sub-matchers for a single sequence */


var SequenceNode = function SequenceNode(ast, depth, opts) {
  this.ast = ast;
  this.depth = depth || 0;
  var indexId = t.identifier("index_" + depth);
  var blockId = t.identifier("block_" + this.depth);
  this.returnStatement = opts.returnStatement;
  this.assignIndex = ast.alternation ? new AssignIndexNode(indexId) : null;
  this.quantifiers = ast.sequence.map(function (childAst) {
    return new QuantifierNode(childAst, depth, _extends({}, opts, {
      restoreIndex: ast.alternation ? new RestoreIndexNode(indexId) : opts.restoreIndex,
      abortCondition: ast.alternation ? null : opts.abortCondition,
      abort: ast.alternation ? new AbortNode(blockId) : opts.abort
    }));
  });
};

function _ref(block, node) {
  block.push.apply(block, node.statements());
  return block;
}

SequenceNode.prototype.statements = function statements() {
  var blockId = t.identifier("block_" + this.depth);
  var alternationId = t.identifier("alternation_" + this.depth);
  var statements = this.quantifiers.reduce(_ref, []);

  if (!this.ast.alternation) {
    return statements;
  }

  var abortNode = this.depth === 0 ? this.returnStatement : t.breakStatement(alternationId);
  return [t.labeledStatement(blockId, t.blockStatement([this.assignIndex && this.assignIndex.statement()].concat(statements, [abortNode])))];
};
/** Generates matchers for sequences with (or without) alternations */


var AlternationNode = function AlternationNode(ast, depth, opts) {
  this.ast = ast;
  this.depth = depth || 0;
  this.sequences = [];

  for (var current = ast; current; current = current.alternation) {
    this.sequences.push(new SequenceNode(current, depth, opts));
  }
};

AlternationNode.prototype.statements = function statements() {
  if (this.sequences.length === 1) {
    return this.sequences[0].statements();
  }

  var statements = [];

  for (var i = 0; i < this.sequences.length; i++) {
    statements.push.apply(statements, this.sequences[i].statements());
  }

  if (this.depth === 0) {
    return statements;
  }

  var alternationId = t.identifier("alternation_" + this.depth);
  return [t.labeledStatement(alternationId, t.blockStatement(statements))];
};

var RootNode = function RootNode(ast, nameNode, transformNode) {
  var indexId = t.identifier('last_index');
  var node = t.callExpression(ids.tag, [ids.node, nameNode]);
  this.returnStatement = t.returnStatement(transformNode ? t.callExpression(transformNode, [node]) : node);
  this.assignIndex = new AssignIndexNode(indexId);
  this.node = new AlternationNode(ast, 0, {
    returnStatement: this.returnStatement,
    restoreIndex: new RestoreIndexNode(indexId, true),
    restoreLength: null,
    abortCondition: null,
    abort: new AbortNode(),
    capturing: true
  });
};

RootNode.prototype.statements = function statements() {
  return [this.assignIndex.statement(), t.variableDeclaration('var', [t.variableDeclarator(ids.match), t.variableDeclarator(ids.node, t.arrayExpression())])].concat(this.node.statements(), [this.returnStatement]);
};

function _ref3(x) {
  return x[1];
}

function _ref4(x) {
  return x.value.cooked;
}

function makeHelpers(t) {
  var regexPatternsRe = /^[()\[\]|.+?*]|[^\\][()\[\]|.+?*$^]|\\[wdsWDS]/;
  var importSourceRe = /reghex$|^reghex\/macro/;
  var importName = 'reghex';
  var ids = new SharedIds(t);
  initGenerator(ids, t);
  var _hasUpdatedImport = false;

  function _ref(node) {
    return t.isImportDefaultSpecifier(node);
  }

  function _ref2(node) {
    return t.isImportSpecifier(node) && node.imported.name === 'tag';
  }

  return {
    /** Adds the reghex import declaration to the Program scope */
    updateImport: function updateImport(path) {
      if (_hasUpdatedImport) {
        return;
      }

      if (!importSourceRe.test(path.node.source.value)) {
        return;
      }

      _hasUpdatedImport = true;
      var defaultSpecifierIndex = path.node.specifiers.findIndex(_ref);

      if (defaultSpecifierIndex > -1) {
        path.node.specifiers.splice(defaultSpecifierIndex, 1);
      }

      if (path.node.source.value !== importName) {
        path.node.source = t.stringLiteral(importName);
      }

      path.node.specifiers.push(t.importSpecifier(ids.execId = path.scope.generateUidIdentifier('exec'), t.identifier('_exec')), t.importSpecifier(ids.substrId = path.scope.generateUidIdentifier('substr'), t.identifier('_substr')), t.importSpecifier(ids.patternId = path.scope.generateUidIdentifier('pattern'), t.identifier('_pattern')));
      var tagImport = path.node.specifiers.find(_ref2);

      if (!tagImport) {
        path.node.specifiers.push(t.importSpecifier(ids.tagId = path.scope.generateUidIdentifier('tag'), t.identifier('tag')));
      } else {
        ids.tagId = tagImport.imported;
      }
    },

    /** Determines whether the given tagged template expression is a reghex match */
    isMatch: function isMatch(path) {
      if (t.isTaggedTemplateExpression(path.node) && t.isCallExpression(path.node.tag) && t.isIdentifier(path.node.tag.callee) && path.scope.hasBinding(path.node.tag.callee.name)) {
        if (t.isVariableDeclarator(path.parentPath)) {
          path.parentPath._isMatch = true;
        }

        return true;
      }

      return t.isVariableDeclarator(path.parentPath) && path.parentPath._isMatch;
    },

    /** Given a reghex match, returns the path to reghex's match import declaration */
    getMatchImport: function getMatchImport(path) {
      t.assertTaggedTemplateExpression(path.node);
      var binding = path.scope.getBinding(path.node.tag.callee.name);

      if (binding.kind !== 'module' || !t.isImportDeclaration(binding.path.parent) || !importSourceRe.test(binding.path.parent.source.value) || !t.isImportDefaultSpecifier(binding.path.node)) {
        return null;
      }

      return binding.path.parentPath;
    },

    /** Given a match, returns an evaluated name or a best guess */
    getMatchName: function getMatchName(path) {
      t.assertTaggedTemplateExpression(path.node);
      var nameArgumentPath = path.get('tag.arguments.0');
      var ref = nameArgumentPath.evaluate();
      var confident = ref.confident;
      var value = ref.value;

      if (!confident && t.isIdentifier(nameArgumentPath.node)) {
        return nameArgumentPath.node.name;
      } else if (confident && typeof value === 'string') {
        return value;
      } else {
        return path.scope.generateUidIdentifierBasedOnNode(path.node);
      }
    },

    /** Given a match, hoists its expressions in front of the match's statement */
    _prepareExpressions: function _prepareExpressions(path) {
      var this$1 = this;
      t.assertTaggedTemplateExpression(path.node);
      var variableDeclarators = [];
      var matchName = this.getMatchName(path);
      var hoistedExpressions = path.node.quasi.expressions.map(function (expression, i) {
        if (t.isIdentifier(expression) && path.scope.hasBinding(expression.name)) {
          var binding = path.scope.getBinding(expression.name);

          if (t.isVariableDeclarator(binding.path.node)) {
            var matchPath = binding.path.get('init');

            if (this$1.isMatch(matchPath)) {
              return expression;
            }
          }
        } else if (t.isRegExpLiteral(expression) && !regexPatternsRe.test(expression.pattern)) {
          // NOTE: This is an optimisation path, where the pattern regex is inlined
          // and has determined to be "simple" enough to be turned into a string
          return t.stringLiteral(expression.pattern.replace(/\\./g, _ref3));
        }

        var id = path.scope.generateUidIdentifier(matchName + "_expression");
        variableDeclarators.push(t.variableDeclarator(id, t.callExpression(ids.pattern, [expression])));
        return id;
      });

      if (variableDeclarators.length) {
        path.getStatementParent().insertBefore(t.variableDeclaration('var', variableDeclarators));
      }

      return hoistedExpressions.map(function (id) {
        // Use _substr helper instead if the expression is a string
        if (t.isStringLiteral(id)) {
          return t.callExpression(ids.substr, [ids.state, id]);
        } // Directly call expression if it's sure to be another matcher


        var binding = path.scope.getBinding(id.name);

        if (binding && t.isVariableDeclarator(binding.path.node)) {
          var matchPath = binding.path.get('init');

          if (this$1.isMatch(matchPath)) {
            return t.callExpression(id, [ids.state]);
          }
        }

        return t.callExpression(ids.exec, [ids.state, id]);
      });
    },
    _prepareTransform: function _prepareTransform(path) {
      var transformNode = path.node.tag.arguments[1];

      if (!transformNode) {
        return null;
      }

      if (t.isIdentifier(transformNode)) {
        return transformNode;
      }

      var matchName = this.getMatchName(path);
      var id = path.scope.generateUidIdentifier(matchName + "_transform");
      var declarator = t.variableDeclarator(id, transformNode);
      path.getStatementParent().insertBefore(t.variableDeclaration('var', [declarator]));
      return id;
    },
    transformMatch: function transformMatch(path) {
      if (!path.node.tag.arguments.length) {
        throw path.get('tag').buildCodeFrameError('match() must at least be called with a node name');
      }

      var matchName = this.getMatchName(path);
      var nameNode = path.node.tag.arguments[0];
      var quasis = path.node.quasi.quasis.map(_ref4);

      var expressions = this._prepareExpressions(path);

      var transformNode = this._prepareTransform(path);

      var ast;

      try {
        ast = parse(quasis, expressions);
      } catch (error) {
        if (error.name !== 'SyntaxError') {
          throw error;
        }

        throw path.get('quasi').buildCodeFrameError(error.message);
      }

      var generator = new RootNode(ast, nameNode, transformNode);
      var body = t.blockStatement(generator.statements());
      var matchFunctionId = path.scope.generateUidIdentifier(matchName);
      var matchFunction = t.functionExpression(matchFunctionId, [ids.state], body);
      path.replaceWith(matchFunction);
    }
  };
}

export { makeHelpers as m };
//# sourceMappingURL=6aa3c7dc.mjs.map
