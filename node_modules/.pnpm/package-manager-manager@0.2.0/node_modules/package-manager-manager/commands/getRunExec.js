var y = (r, e, t) => {
  if (!e.has(r))
    throw TypeError("Cannot " + t);
};
var u = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
};
var l = (r, e, t) => (y(r, e, "access private method"), t);
var n, f, a, w;
const i = class {
  constructor(e, t, s) {
    this.pkgCmd = t, this.pmCmd = void 0, this.targetArgs = (s == null ? void 0 : s.args) ?? [];
    const d = (s == null ? void 0 : s.format) ?? "short", m = (s == null ? void 0 : s.download) ?? "prefer-always";
    this.cmd = e.name, this.structIsReady = new Promise((h) => {
      var g;
      l(g = i, n, f).call(g, e, t, d, m).then(
        ({ cmd: b, pmCmd: C }) => {
          var x;
          this.cmd = b, this.pmCmd = C, ["yarn", "pnpm"].includes(e.name) && C === "exec" && (this.pkgCmd = l(x = i, a, w).call(x, this.pkgCmd)), e.name === "npm" && this.pmCmd === "exec" && (this.argsNeedDoubleDashes = !0), h();
        }
      );
    }), this.argsNeedDoubleDashes = e.metadata.isYarnClassic;
  }
  get cmdArgs() {
    return [
      ...this.pmCmd ? [this.pmCmd] : [],
      this.pkgCmd,
      ...this.targetArgs.length && this.argsNeedDoubleDashes ? ["--"] : [],
      ...this.targetArgs
    ];
  }
  toString() {
    return `${this.cmd}${this.pmCmd ? ` ${this.pmCmd}` : ""} ${this.pkgCmd}${this.targetArgs.length ? `${this.argsNeedDoubleDashes ? " --" : ""} ${this.targetArgs.join(" ")}` : ""}`;
  }
};
let c = i;
n = new WeakSet(), f = async function(e, t, s, d) {
  switch (e.name) {
    case "bun":
      return s === "short" ? { cmd: "bunx" } : { cmd: "bun", pmCmd: "x" };
    case "npm":
      return s === "short" ? { cmd: "npx" } : { cmd: "npm", pmCmd: "exec" };
    case "yarn":
      if (e.metadata.isYarnClassic)
        return { cmd: "yarn", pmCmd: "exec" };
      break;
  }
  const m = { cmd: e.name };
  switch (d) {
    case "prefer-always":
      m.pmCmd = "dlx";
      break;
    case "prefer-never":
      m.pmCmd = "exec";
      break;
    case "prefer-if-needed": {
      const h = await e.getPackageInfo(t);
      m.pmCmd = h ? "exec" : "dlx";
      break;
    }
  }
  return m;
}, a = new WeakSet(), w = function(e) {
  const t = e.match(/^@[^/]+\/(.*)/);
  return (t == null ? void 0 : t[1]) ?? e;
}, u(c, n), /**
 * Unscopes a given command, for example it converts "@org/my-cmd" to "my-cmd"
 * (already non scoped commands are left untouched)
 *
 * @param command the command to potentially unscope
 * @returns the unscoped version of the provided command
 */
u(c, a);
function $(r) {
  const e = async (s, d) => {
    if (!s)
      return null;
    const m = new c(r, s, d);
    return await m.structIsReady, m;
  };
  return { getRunExec: async (...s) => {
    var d;
    return ((d = await e(...s)) == null ? void 0 : d.toString()) ?? null;
  }, getRunExecStruct: e };
}
export {
  $ as getRunExecFunctions
};
//# sourceMappingURL=getRunExec.js.map
