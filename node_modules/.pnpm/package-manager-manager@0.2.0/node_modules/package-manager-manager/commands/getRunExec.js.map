{"version":3,"file":"getRunExec.js","sources":["../../src/commands/getRunExec.ts"],"sourcesContent":["import type { PackageManager, PackageManagerMetadata } from '../packageManager';\nimport type { CommandExecStruct } from './CommandStruct';\n\n/**\n * The subset of properties of PackageManager that are relevant when dealing with exec commands\n */\ntype PackageManagerForExec = Pick<PackageManager, 'name' | 'version' | 'getPackageInfo'> & {\n\tmetadata: Pick<PackageManagerMetadata, 'isYarnClassic'>;\n};\n\nclass RunExecStruct implements CommandExecStruct {\n\tstructIsReady: Promise<void>;\n\n\tcmd: string;\n\n\tpmCmd?: string = undefined;\n\n\ttargetArgs: string[];\n\n\targsNeedDoubleDashes: boolean;\n\n\tconstructor(\n\t\tpackageManager: PackageManagerForExec,\n\t\tpublic pkgCmd: string,\n\t\toptions?: Partial<GetRunExecOptions>,\n\t) {\n\t\tthis.targetArgs = options?.args ?? [];\n\n\t\tconst format = options?.format ?? 'short';\n\t\tconst download = options?.download ?? 'prefer-always';\n\n\t\tthis.cmd = packageManager.name;\n\t\tthis.structIsReady = new Promise((resolve) => {\n\t\t\tRunExecStruct.#getPmKeywords(packageManager, pkgCmd, format, download).then(\n\t\t\t\t({ cmd, pmCmd }) => {\n\t\t\t\t\tthis.cmd = cmd;\n\t\t\t\t\tthis.pmCmd = pmCmd;\n\n\t\t\t\t\tif (['yarn', 'pnpm'].includes(packageManager.name) && pmCmd === 'exec') {\n\t\t\t\t\t\tthis.pkgCmd = RunExecStruct.#unscopeCommand(this.pkgCmd);\n\t\t\t\t\t}\n\t\t\t\t\tconst isNpmExec = packageManager.name === 'npm' && this.pmCmd === 'exec';\n\t\t\t\t\tif (isNpmExec) {\n\t\t\t\t\t\tthis.argsNeedDoubleDashes = true;\n\t\t\t\t\t}\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\n\t\tthis.argsNeedDoubleDashes = packageManager.metadata.isYarnClassic;\n\t}\n\n\tget cmdArgs(): string[] {\n\t\treturn [\n\t\t\t...(this.pmCmd ? [this.pmCmd] : []),\n\t\t\tthis.pkgCmd,\n\t\t\t...(this.targetArgs.length && this.argsNeedDoubleDashes ? ['--'] : []),\n\t\t\t...this.targetArgs,\n\t\t];\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.cmd}${this.pmCmd ? ` ${this.pmCmd}` : ''} ${this.pkgCmd}${\n\t\t\tthis.targetArgs.length\n\t\t\t\t? `${this.argsNeedDoubleDashes ? ' --' : ''} ${this.targetArgs.join(' ')}`\n\t\t\t\t: ''\n\t\t}`;\n\t}\n\n\tstatic async #getPmKeywords(\n\t\tpackageManager: PackageManagerForExec,\n\t\tcommand: string,\n\t\tformat: 'short' | 'full',\n\t\tdownload: DownloadPreference,\n\t): Promise<{ cmd: string; pmCmd?: string }> {\n\t\tswitch (packageManager.name) {\n\t\t\tcase 'bun':\n\t\t\t\treturn format === 'short' ? { cmd: 'bunx' } : { cmd: 'bun', pmCmd: 'x' };\n\t\t\tcase 'npm':\n\t\t\t\treturn format === 'short' ? { cmd: 'npx' } : { cmd: 'npm', pmCmd: 'exec' };\n\t\t\tcase 'yarn':\n\t\t\t\tif (packageManager.metadata.isYarnClassic) {\n\t\t\t\t\t// yarn classic doesn't have dlx\n\t\t\t\t\treturn { cmd: 'yarn', pmCmd: 'exec' };\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\n\t\tconst result: { cmd: string; pmCmd?: string } = { cmd: packageManager.name };\n\t\t// eslint-disable-next-line default-case\n\t\tswitch (download) {\n\t\t\tcase 'prefer-always':\n\t\t\t\tresult.pmCmd = 'dlx';\n\t\t\t\tbreak;\n\t\t\tcase 'prefer-never':\n\t\t\t\tresult.pmCmd = 'exec';\n\t\t\t\tbreak;\n\t\t\tcase 'prefer-if-needed': {\n\t\t\t\tconst isPackageInstalled = await packageManager.getPackageInfo(command);\n\t\t\t\tresult.pmCmd = isPackageInstalled ? 'exec' : 'dlx';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Unscopes a given command, for example it converts \"@org/my-cmd\" to \"my-cmd\"\n\t * (already non scoped commands are left untouched)\n\t *\n\t * @param command the command to potentially unscope\n\t * @returns the unscoped version of the provided command\n\t */\n\tstatic #unscopeCommand(command: string): string {\n\t\tconst match = command.match(/^@[^/]+\\/(.*)/);\n\t\treturn match?.[1] ?? command;\n\t}\n}\n\nexport type GetRunExecOptions = {\n\t/**\n\t * The arguments to pass to the command (e.g. `-h`, `--info`, etc...)\n\t *\n\t * defaults to `[]`\n\t */\n\targs: string[];\n\t/**\n\t * Wether the command represents a full command or a shortened one\n\t * (i.e. whether unnecessary keywords are removed/compressed or not)\n\t * (e.g. short format = `'npx eslint'`, long format = `'npm exec eslint'`)\n\t *\n\t * defaults to `'short'`\n\t */\n\tformat: 'full' | 'short';\n\t/**\n\t * Indication of how the resulting command should be set up in regards of downloading\n\t * missing packages (this option does not guarantee a specific behavior as this heavily\n\t * relies on the underlying package manager in use)\n\t *\n\t * defaults to `'prefer-always'`\n\t */\n\tdownload: DownloadPreference;\n};\n\ntype DownloadPreference = 'prefer-never' | 'prefer-always' | 'prefer-if-needed';\n\nexport type GetRunExec = (\n\tcommand: string,\n\toptions?: Partial<GetRunExecOptions>,\n) => Promise<string | null>;\n\nexport type GetRunExecStruct = (\n\tcommand: string,\n\toptions?: Partial<GetRunExecOptions>,\n) => Promise<CommandExecStruct | null>;\n\nexport function getRunExecFunctions(packageManager: PackageManagerForExec): {\n\tgetRunExec: GetRunExec;\n\tgetRunExecStruct: GetRunExecStruct;\n} {\n\tconst getRunExecStruct: GetRunExecStruct = async (command, options) => {\n\t\tif (!command) return null;\n\t\tconst struct = new RunExecStruct(packageManager, command, options);\n\t\tawait struct.structIsReady;\n\t\treturn struct;\n\t};\n\n\tconst getRunExec: GetRunExec = async (...args) =>\n\t\t(await getRunExecStruct(...args))?.toString() ?? null;\n\n\treturn { getRunExec, getRunExecStruct };\n}\n"],"names":["_getPmKeywords","getPmKeywords_fn","_unscopeCommand","unscopeCommand_fn","_RunExecStruct","packageManager","pkgCmd","options","format","download","resolve","_a","__privateMethod","cmd","pmCmd","RunExecStruct","command","result","isPackageInstalled","match","__privateAdd","getRunExecFunctions","getRunExecStruct","struct","args"],"mappings":"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"}