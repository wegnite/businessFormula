{"version":3,"file":"getRunExec.cjs","sources":["../../src/commands/getRunExec.ts"],"sourcesContent":["import type { PackageManager, PackageManagerMetadata } from '../packageManager';\nimport type { CommandExecStruct } from './CommandStruct';\n\n/**\n * The subset of properties of PackageManager that are relevant when dealing with exec commands\n */\ntype PackageManagerForExec = Pick<PackageManager, 'name' | 'version' | 'getPackageInfo'> & {\n\tmetadata: Pick<PackageManagerMetadata, 'isYarnClassic'>;\n};\n\nclass RunExecStruct implements CommandExecStruct {\n\tstructIsReady: Promise<void>;\n\n\tcmd: string;\n\n\tpmCmd?: string = undefined;\n\n\ttargetArgs: string[];\n\n\targsNeedDoubleDashes: boolean;\n\n\tconstructor(\n\t\tpackageManager: PackageManagerForExec,\n\t\tpublic pkgCmd: string,\n\t\toptions?: Partial<GetRunExecOptions>,\n\t) {\n\t\tthis.targetArgs = options?.args ?? [];\n\n\t\tconst format = options?.format ?? 'short';\n\t\tconst download = options?.download ?? 'prefer-always';\n\n\t\tthis.cmd = packageManager.name;\n\t\tthis.structIsReady = new Promise((resolve) => {\n\t\t\tRunExecStruct.#getPmKeywords(packageManager, pkgCmd, format, download).then(\n\t\t\t\t({ cmd, pmCmd }) => {\n\t\t\t\t\tthis.cmd = cmd;\n\t\t\t\t\tthis.pmCmd = pmCmd;\n\n\t\t\t\t\tif (['yarn', 'pnpm'].includes(packageManager.name) && pmCmd === 'exec') {\n\t\t\t\t\t\tthis.pkgCmd = RunExecStruct.#unscopeCommand(this.pkgCmd);\n\t\t\t\t\t}\n\t\t\t\t\tconst isNpmExec = packageManager.name === 'npm' && this.pmCmd === 'exec';\n\t\t\t\t\tif (isNpmExec) {\n\t\t\t\t\t\tthis.argsNeedDoubleDashes = true;\n\t\t\t\t\t}\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\n\t\tthis.argsNeedDoubleDashes = packageManager.metadata.isYarnClassic;\n\t}\n\n\tget cmdArgs(): string[] {\n\t\treturn [\n\t\t\t...(this.pmCmd ? [this.pmCmd] : []),\n\t\t\tthis.pkgCmd,\n\t\t\t...(this.targetArgs.length && this.argsNeedDoubleDashes ? ['--'] : []),\n\t\t\t...this.targetArgs,\n\t\t];\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.cmd}${this.pmCmd ? ` ${this.pmCmd}` : ''} ${this.pkgCmd}${\n\t\t\tthis.targetArgs.length\n\t\t\t\t? `${this.argsNeedDoubleDashes ? ' --' : ''} ${this.targetArgs.join(' ')}`\n\t\t\t\t: ''\n\t\t}`;\n\t}\n\n\tstatic async #getPmKeywords(\n\t\tpackageManager: PackageManagerForExec,\n\t\tcommand: string,\n\t\tformat: 'short' | 'full',\n\t\tdownload: DownloadPreference,\n\t): Promise<{ cmd: string; pmCmd?: string }> {\n\t\tswitch (packageManager.name) {\n\t\t\tcase 'bun':\n\t\t\t\treturn format === 'short' ? { cmd: 'bunx' } : { cmd: 'bun', pmCmd: 'x' };\n\t\t\tcase 'npm':\n\t\t\t\treturn format === 'short' ? { cmd: 'npx' } : { cmd: 'npm', pmCmd: 'exec' };\n\t\t\tcase 'yarn':\n\t\t\t\tif (packageManager.metadata.isYarnClassic) {\n\t\t\t\t\t// yarn classic doesn't have dlx\n\t\t\t\t\treturn { cmd: 'yarn', pmCmd: 'exec' };\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\n\t\tconst result: { cmd: string; pmCmd?: string } = { cmd: packageManager.name };\n\t\t// eslint-disable-next-line default-case\n\t\tswitch (download) {\n\t\t\tcase 'prefer-always':\n\t\t\t\tresult.pmCmd = 'dlx';\n\t\t\t\tbreak;\n\t\t\tcase 'prefer-never':\n\t\t\t\tresult.pmCmd = 'exec';\n\t\t\t\tbreak;\n\t\t\tcase 'prefer-if-needed': {\n\t\t\t\tconst isPackageInstalled = await packageManager.getPackageInfo(command);\n\t\t\t\tresult.pmCmd = isPackageInstalled ? 'exec' : 'dlx';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Unscopes a given command, for example it converts \"@org/my-cmd\" to \"my-cmd\"\n\t * (already non scoped commands are left untouched)\n\t *\n\t * @param command the command to potentially unscope\n\t * @returns the unscoped version of the provided command\n\t */\n\tstatic #unscopeCommand(command: string): string {\n\t\tconst match = command.match(/^@[^/]+\\/(.*)/);\n\t\treturn match?.[1] ?? command;\n\t}\n}\n\nexport type GetRunExecOptions = {\n\t/**\n\t * The arguments to pass to the command (e.g. `-h`, `--info`, etc...)\n\t *\n\t * defaults to `[]`\n\t */\n\targs: string[];\n\t/**\n\t * Wether the command represents a full command or a shortened one\n\t * (i.e. whether unnecessary keywords are removed/compressed or not)\n\t * (e.g. short format = `'npx eslint'`, long format = `'npm exec eslint'`)\n\t *\n\t * defaults to `'short'`\n\t */\n\tformat: 'full' | 'short';\n\t/**\n\t * Indication of how the resulting command should be set up in regards of downloading\n\t * missing packages (this option does not guarantee a specific behavior as this heavily\n\t * relies on the underlying package manager in use)\n\t *\n\t * defaults to `'prefer-always'`\n\t */\n\tdownload: DownloadPreference;\n};\n\ntype DownloadPreference = 'prefer-never' | 'prefer-always' | 'prefer-if-needed';\n\nexport type GetRunExec = (\n\tcommand: string,\n\toptions?: Partial<GetRunExecOptions>,\n) => Promise<string | null>;\n\nexport type GetRunExecStruct = (\n\tcommand: string,\n\toptions?: Partial<GetRunExecOptions>,\n) => Promise<CommandExecStruct | null>;\n\nexport function getRunExecFunctions(packageManager: PackageManagerForExec): {\n\tgetRunExec: GetRunExec;\n\tgetRunExecStruct: GetRunExecStruct;\n} {\n\tconst getRunExecStruct: GetRunExecStruct = async (command, options) => {\n\t\tif (!command) return null;\n\t\tconst struct = new RunExecStruct(packageManager, command, options);\n\t\tawait struct.structIsReady;\n\t\treturn struct;\n\t};\n\n\tconst getRunExec: GetRunExec = async (...args) =>\n\t\t(await getRunExecStruct(...args))?.toString() ?? null;\n\n\treturn { getRunExec, getRunExecStruct };\n}\n"],"names":["_RunExecStruct","packageManager","pkgCmd","options","format","download","resolve","__privateMethod","_a","_getPmKeywords","getPmKeywords_fn","cmd","pmCmd","_unscopeCommand","unscopeCommand_fn","RunExecStruct","command","result","isPackageInstalled","match","__privateAdd","getRunExecFunctions","getRunExecStruct","struct","args"],"mappings":"oVAUA,MAAMA,EAAN,KAAiD,CAWhD,YACCC,EACOC,EACPC,EACC,CAFM,KAAA,OAAAD,EARS,KAAA,MAAA,OAWX,KAAA,YAAaC,GAAA,YAAAA,EAAS,OAAQ,CAAA,EAE7B,MAAAC,GAASD,GAAA,YAAAA,EAAS,SAAU,QAC5BE,GAAWF,GAAA,YAAAA,EAAS,WAAY,gBAEtC,KAAK,IAAMF,EAAe,KAC1B,KAAK,cAAgB,IAAI,QAASK,GAAY,OAC7CC,EAAAC,EAAAR,EAAcS,EAAAC,GAAd,KAAAF,EAA6BP,EAAgBC,EAAQE,EAAQC,GAAU,KACtE,CAAC,CAAE,IAAAM,EAAK,MAAAC,KAAY,OACnB,KAAK,IAAMD,EACX,KAAK,MAAQC,EAET,CAAC,OAAQ,MAAM,EAAE,SAASX,EAAe,IAAI,GAAKW,IAAU,SAC/D,KAAK,OAASL,EAAAC,EAAAR,EAAca,EAAAC,GAAd,KAAAN,EAA8B,KAAK,SAEhCP,EAAe,OAAS,OAAS,KAAK,QAAU,SAEjE,KAAK,qBAAuB,IAErBK,GACT,CAAA,CACD,CACA,EAEI,KAAA,qBAAuBL,EAAe,SAAS,aACrD,CAEA,IAAI,SAAoB,CAChB,MAAA,CACN,GAAI,KAAK,MAAQ,CAAC,KAAK,KAAK,EAAI,CAAC,EACjC,KAAK,OACL,GAAI,KAAK,WAAW,QAAU,KAAK,qBAAuB,CAAC,IAAI,EAAI,CAAC,EACpE,GAAG,KAAK,UAAA,CAEV,CAEA,UAAmB,CACX,MAAA,GAAG,KAAK,MAAM,KAAK,MAAQ,IAAI,KAAK,QAAU,MAAM,KAAK,SAC/D,KAAK,WAAW,OACb,GAAG,KAAK,qBAAuB,MAAQ,MAAM,KAAK,WAAW,KAAK,GAAG,IACrE,IAEL,CAoDD,EA9GA,IAAMc,EAANf,EA4DcS,EAAA,YAAAC,EAAA,eACZT,EACAe,EACAZ,EACAC,EAC2C,CAC3C,OAAQJ,EAAe,KAAM,CAC5B,IAAK,MACG,OAAAG,IAAW,QAAU,CAAE,IAAK,MAAA,EAAW,CAAE,IAAK,MAAO,MAAO,KACpE,IAAK,MACG,OAAAA,IAAW,QAAU,CAAE,IAAK,KAAA,EAAU,CAAE,IAAK,MAAO,MAAO,QACnE,IAAK,OACA,GAAAH,EAAe,SAAS,cAE3B,MAAO,CAAE,IAAK,OAAQ,MAAO,MAAO,EAErC,KAEF,CAEA,MAAMgB,EAA0C,CAAE,IAAKhB,EAAe,IAAK,EAE3E,OAAQI,EAAU,CACjB,IAAK,gBACJY,EAAO,MAAQ,MACf,MACD,IAAK,eACJA,EAAO,MAAQ,OACf,MACD,IAAK,mBAAoB,CACxB,MAAMC,EAAqB,MAAMjB,EAAe,eAAee,CAAO,EAC/DC,EAAA,MAAQC,EAAqB,OAAS,MAC7C,KACD,CACD,CAEO,OAAAD,CACR,EASOJ,EAAA,YAAAC,WAAgBE,EAAyB,CACzC,MAAAG,EAAQH,EAAQ,MAAM,eAAe,EACpC,OAAAG,GAAA,YAAAA,EAAQ,KAAMH,CACtB,EAjDAI,EA5DKL,EA4DQN,GA8CbW,EA1GKL,EA0GEF,GA2CD,SAASQ,EAAoBpB,EAGlC,CACK,MAAAqB,EAAqC,MAAON,EAASb,IAAY,CACtE,GAAI,CAACa,EAAgB,OAAA,KACrB,MAAMO,EAAS,IAAIR,EAAcd,EAAgBe,EAASb,CAAO,EACjE,aAAMoB,EAAO,cACNA,CAAA,EAMD,MAAA,CAAE,WAHsB,SAAUC,WACvC,QAAAhB,EAAA,MAAMc,EAAiB,GAAGE,CAAI,IAA9B,YAAAhB,EAAkC,aAAc,MAE7B,iBAAAc,EACtB"}